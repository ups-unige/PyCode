"""
Collection of utilities to automate some SpyCode operations
Author: Mascelli Leonardo
Last Edited: 22-09-2023
"""

from os import listdir, makedirs
from pathlib import Path
from shutil import copyfile, move
from typing import List, Optional, Tuple

import numpy as np
from scipy.io import loadmat

from pycode.matlab import iMatlabInterface
from pycode.utils import data_in_intervals

###############################################################################
#                                                                             #
#                               GLOBALS                                       #
#                                                                             #
###############################################################################

convert_template = """
% -*-MATLAB-*-

%{
script template that build an experiment from the working directory and saves
the result in an unique file importable in Python

PLACEHOLDERS:
- library_path        %[0]: path of the PyCode library files
- root_directory      %[1]: path of the experiment raw data
- active_els          %[2]: list of active electrodes
- save_path           %[3]: path of the exported file
%}

clear all; %#ok<CLALL>
clc;
library_path = %[0];
addpath([library_path '/pycode/matlab/'])

root_directory = %[1];
options = make_experiment_options(root_directory);
active_els = %[2];
save_path = %[3];

stored = store_experiment(root_directory, active_els, save_path);
"""


###############################################################################
#                                                                             #
#                             PATH MANAGEMENT                                 #
#                                                                             #
###############################################################################


class Path_Generator:
    """
    It is often necessary to get the absolute path of a resourse generated by
    SpyCode and those paths aren't easy to remember (at least to me). This
    class is a generator of path from the ROOT folder of an experiment data.
    <MCD_NAME> -> <MATRIX_NAME>_Mat_files -> <MATRIX_NAME>_Mat_files -> <MCD_NAME> -> <MCD_NAME>_<EL_NUMBER>.mat
                                                                                      <MCD_NAME>_<EL_NUMBER>.mat
                                                                                      <MCD_NAME>_<EL_NUMBER>.mat
                                                                                      ...
    """

    def __init__(self, root: Path, mcd_name: str):
        """
        Path Generator constructor
        @param [in] root: the root folder of the converted mcds
        @param [in] name: the name of the mcd file
        """
        self.root = root
        self.name = mcd_name[: mcd_name.rfind(".")]

    def base_electrode_path(self, electrode_number: int) -> Path:
        """
        @param [in] electrode_number
        @returns the path of the .mat file of an electrode raw data as
        recorded
        """
        return self.mat_folder().joinpath(self.name + '_' +
                                          str(electrode_number) + '.mat')

    def filtered_electrode_path(self, electrode_number: int) -> Path:
        """
        @param [in] electrode_number
        @returns the path of the .mat file of a filtered electrode raw data
        """
        return (self.filtered_folder()
                .joinpath(f"{self.matrix_name()}_Mat_files")
                .joinpath(self.name)
                .joinpath(self.name + '_' +
                          str(electrode_number) + '.mat')
                )

    def matrix_name(self) -> str:
        """
        @returns the colture name/ID
        """
        return self.name[: self.name.find("_")]

    def mat_folder(self) -> Path:
        """
        @returns the folder containing the unfiltered mat files
        """
        return (
            self.root.joinpath(self.name)
            .joinpath(self.matrix_name())
            .joinpath(f"{self.matrix_name()}_Mat_files")
            .joinpath(f"{self.matrix_name()}_Mat_files")
            .joinpath(f"{self.name}")
            .absolute()
        )

    def filtered_folder(self) -> Path:
        """
        @returns the default path of the filtered folder for SpyCode
        """
        return (
            self.root.joinpath(self.name)
            .joinpath(self.matrix_name())
            .joinpath(f"{self.matrix_name()}_Mat_files")
            .joinpath(f"{self.matrix_name()}_FilteredData")
            .absolute()
        )

    def peak_folder_name(self, plp: str = "2ms", rp: str = "1ms") -> str:
        """
        Generate the default name used by SpyCode for the peak folder
        @param [in] plp: peak length period
        @param [in] rp: refractary period
        @returns name for the peak folder
        """
        return f"{self.matrix_name()}_PeakDetectionMAT_PLP{plp}_RP{rp}"

    def argument_convert(self) -> Path:
        """
        @returns the default path where to store the conversion files
        """
        return self.root.absolute()

    def argument_filter_src(self) -> Path:
        """
        @returns the default path where to look for mat to be converted
        """
        print(f"***{self.name}")
        return (
            self.root.joinpath(f"{self.name}")
            .joinpath(f"{self.matrix_name()}_Mat_files")
            .absolute()
        )

    def argument_filter_dst(self) -> Path:
        """
        @returns the default path where to store converted mat files
        """
        return (
            self.root.joinpath(f"{self.name}")
            .joinpath(f"{self.matrix_name()}_Mat_files")
            .joinpath(f"{self.matrix_name()}_FilteredData")
            .joinpath(f"{self.matrix_name()}_Mat_Files")
            .absolute()
        )

    def argument_spike_detection_src(self) -> Path:
        """
        @returns the default path where to look for filtered mat on which to
                 compute the spike detection
        """
        return (
            self.root.joinpath(f"{self.name}")
            .joinpath(f"{self.matrix_name()}_Mat_files")
            .joinpath(f"{self.matrix_name()}_FilteredData")
            .joinpath(f"{self.matrix_name()}_Mat_Files")
            .absolute()
        )

    def argument_spike_detection_dst(self) -> Path:
        """
        @returns the default path where to store the result of the spike
                 detection
        """
        return (
            self.argument_spike_detection_src()
            .parent.joinpath(self.peak_folder_name())
            .absolute()
        )


###############################################################################
#                                                                             #
#                             UTILITY FUNCTIONS                               #
#                                                                             #
###############################################################################


def organize_mcd_folder(
    src: Path, dst: Path, move_files: bool = False, debug: bool = False
) -> List[Path]:
    """
    Converting the mcds files directly from SpyCode puts the conversion files
    in the same folder as the original raw data and that could lead to some
    confusion. This function copy each file in a separate directory with the
    same name as the file itself.

    @param [in] src: path of the mcd files
    @param [in] dst: root directory of the new folders
    @returns a list of path of the new folders
    """

    ret = []

    print(f"Copying files from {src} to {dst}")
    for f in listdir(src):
        if Path(src.joinpath(f)).is_file():
            if f.endswith(".mcd"):
                new_dir_name = dst.joinpath(f.removesuffix(".mcd"))
                dest_path = new_dir_name.joinpath(f)
                if debug:
                    ret.append(dest_path.absolute())
                else:
                    print(f"{'moving' if move_files else 'copying'} {f}")
                    makedirs(new_dir_name)
                    if move_files:
                        move(src.joinpath(f), dest_path)
                        ret.append(dest_path.absolute())
                    else:
                        copyfile(src.joinpath(f), dest_path)
                        ret.append(dest_path.absolute())
    return ret


def convert_from_spycode_data(
        matlab: iMatlabInterface,
        data_path: Path,
        save_path: Optional[Path],
        active_els: List[int] = []):
    """
    Convert a SpyCode set of data in a single file importable to PyCode
    @param [in] matlab: the MATLAB interface
    @param [in] data_path: the path of the SpyCode data
    @param [in] save_path: the path of the generated export
    @param [in] active_els: the list of electrode to export
    """
    if save_path is None:
        save_path = data_path
    matlab.cwd = data_path
    matlab.exit = True
    content = convert_template
    content = content.replace("%[0]", f"'{matlab.library_path}'")
    content = content.replace("%[1]", f"'{data_path.absolute()}'")
    content_active_els = "["
    for el in active_els:
        content_active_els = content_active_els + f"{el} "
    content_active_els = content_active_els + "]"
    content = content.replace("%[2]", f"{content_active_els}")
    content = content.replace("%[3]", f"'{data_path.absolute()}'")
    with open(data_path.joinpath("convert.m"), "w") as export:
        export.write(content)
    matlab.run_code("convert")


###############################################################################
#                                                                             #
#                          SPYCODE DATA MANAGEMENT                            #
#                                                                             #
###############################################################################


class SpyCodePhase:
    """
    This class provide the direct access to the SpyCode representation of a
    phase as it was a PyCode one.
    """

    base_folder: Path
    name: str

    def __init__(self, base_path: str, name: str):
        """
        @param [in] base_path: root path of data
        @param [in] name: name of the data folder
        """
        self.base_folder = Path(base_path)
        self.name = name

    def get_digital(self) -> Optional[np.ndarray]:
        """
        @returns the digital signal (if any)
        """
        name = self.name
        filepath = Path(f"{self.base_folder}/{name}/{name}/{name}_D1_00.mat")
        if filepath.exists():
            return loadmat(str(filepath.absolute()))["data"]
        else:
            print(f"error finding file {filepath}")
            return None

    def get_el(self, el: int) -> Optional[np.ndarray]:
        """
        @param [in] el: electrode to query for data

        @returns an array with electrode recording (if any)
        """
        name = self.name
        filepath = Path(
            f"{self.base_folder}/{name}/{name}_Mat_files/"
            f"{name}_Mat_files/{name}/{name}_{el}.mat"
        )
        if filepath.exists():
            return loadmat(filepath.absolute())["data"]
        else:
            print(f"error finding file {filepath}")
            return None

    def el_data_while_stimulating(
        self, el: int, guard_pre: int = 0
    ) -> List[Tuple[np.ndarray, np.ndarray]]:
        """
        @param [in] el: the electrode to query for data
        @param [in] guard_pre: offset in the start of the interval
        @returns a list of tuples (data, interval indices)
        """
        el_data = self.get_el(el)
        assert el_data is not None, f"error in reading electrode {el}"
        el_dig = self.get_digital()
        assert el_dig is not None, "error in reading digital signal"

        dig_intervals_indices_start = np.where(
            np.gradient(el_dig[:, 0]) > 0)[0]
        dig_intervals_indices_ends = np.where(np.gradient(el_dig[:, 0]) < 0)[0]

        intervals = []

        for i, n in enumerate(dig_intervals_indices_start):
            intervals.append((n + guard_pre, dig_intervals_indices_ends[i]))

        return data_in_intervals(el_data, intervals)


class SpyCodeExperiment:
    # TODO
    """
    This class provide the direct access to the SpyCode representation of an
    experiment as it was a PyCode one.
    """
    pass


###############################################################################
#                                                                             #
#                             SPYCODE CALLS                                   #
#                                                                             #
###############################################################################


def convert_mcd(
    matlab: iMatlabInterface, src: Path, dst: Path, wait: bool = True
) -> None:
    """
    Convert an mcd file using SpyCode
    @param [in] src: path of the mcd
    @param [in] dst: path of the exported conversion
    @param [in] wait: if True block the python process until the end of the
                      conversion
    """
    if src.exists() and src.is_file() and src.name.endswith(".mcd"):
        matlab.cwd = dst
        matlab.wait = wait
        matlab.run_code(f"convert_mcd('{src}')")
    else:
        print(f"source {src} not found or not an mcd file")


def filter_raw_data(
    matlab: iMatlabInterface,
    src: Path,
    dst: Path,
    filter_type: str,
    cutOff: int,
    sampling_freq: int,
    wait: bool = True,
) -> None:
    """
    Filter a dataset using SpyCode
    @param [in] src: path of the mat files
    @param [in] dst: path of the filtered mat files
    @param [in] filter_type: 'low' or 'high' filter
    @param [in] wait: if True block the python process until the end of the
                      filtering
    """
    matlab.wait = wait
    matlab.run_code(
        f"filter_data('{src}', '{dst}', '{filter_type}', {cutOff}, {sampling_freq})",
    )


def detect_spykes(
    matlab: iMatlabInterface, src: Path,
    dst: Path, params=[], wait: bool = True
) -> None:
    """
    Compute the spike detection on a dataset using SpyCode
    @param [in] src: path of the mat files
    @param [in] dst: path of the converted mat files
    @param [in] params: TODO detection parameters (only default at the moment)
    @param [in] wait : if True block the python process until the end of the
                      spike detection
    """
    _ = params
    matlab.wait = wait
    matlab.run_code(f"spike_detection('{src.absolute()}', '{dst.absolute()}')")


def elaborate_mcd(matlab: iMatlabInterface, mcd: Path):
    """Convert, filter and detect spikes on an mcd file (src) and put
    the converted result in dst. Make dst if not exists.
    """

    assert mcd.is_file(), f"{mcd} is not a file"
    root_folder = mcd.parent.joinpath(mcd.name[: mcd.name.find("_")])
    makedirs(root_folder, exist_ok=True)
    pg = Path_Generator(root_folder, mcd.name)
    print(mcd.parent.absolute())

    #                               CONVERT                                   #

    print(f"converting {pg.name} to {pg.argument_convert()} ...")
    makedirs(pg.argument_convert(), exist_ok=True)
    convert_mcd(matlab, mcd.absolute(), pg.argument_convert())

    #                               FILTER                                    #

    print(f"filtering {pg.name} to {pg.argument_filter_dst()} ...")
    filter_raw_data(
        matlab,
        pg.argument_filter_src(),
        pg.argument_filter_dst(),
        "high",
        70,
        10000,
        True,
    )
    print(pg.argument_filter_src())
    print(pg.argument_filter_dst())

    #                            SPIKE DETECTION                              #

    print(
        f"compuiting spikes detection {pg.name} to {pg.argument_spike_detection_dst()}"
    )
    detect_spykes(
        matlab,
        pg.argument_spike_detection_src(),
        pg.argument_spike_detection_dst(),
        wait=True,
    )


def elaborate_mcd_folder(matlab: iMatlabInterface, src: Path) -> None:
    """Convert, filter and detect spikes on a whole mcd folder (src) and put
    the converted result in dst. Make dst if not exists.
    """
    if src.is_dir():
        files = listdir(src)
        for f in files:
            elaborate_mcd(matlab, Path(f))
    else:
        print("ERROR convert_mcd_folder: pass a directory as src")
        return
